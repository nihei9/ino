package code

import (
	_ "embed"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/nihei9/ino/ir"
)

var (
	//go:embed builtin.tmpl
	builtinTmpl string

	//go:embed data_decl.tmpl
	dataDeclTmpl string

	//go:embed val_cons_decl.tmpl
	valConsDeclTmpl string

	//go:embed data_associated.tmpl
	dataAssociatedTmpl string
)

type CodeGenerator struct {
	PkgName     string
	OutDir      string
	OutFileName string
}

func (g *CodeGenerator) Run(file *ir.File) error {
	f, err := genFile(file)
	if err != nil {
		return err
	}
	outFilePath := filepath.Join(g.OutDir, g.OutFileName)
	out, err := os.OpenFile(outFilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer out.Close()
	f.Name = ast.NewIdent(g.PkgName)
	fmt.Fprintln(out, "// Code generated by ino. DO NOT EDIT.")
	err = format.Node(out, token.NewFileSet(), f)
	if err != nil {
		return err
	}

	{
		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, "", builtinTmpl, 0)
		if err != nil {
			panic(err)
		}
		outFilePath := filepath.Join(g.OutDir, "ino_builtin.go")
		out, err := os.OpenFile(outFilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
		defer out.Close()
		f.Name = ast.NewIdent(g.PkgName)
		fmt.Fprintln(out, "// Code generated by ino. DO NOT EDIT.")
		err = format.Node(out, token.NewFileSet(), f)
		if err != nil {
			return err
		}
	}

	return nil
}

func genFile(file *ir.File) (*ast.File, error) {
	decls := []ast.Decl{
		&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{
				&ast.ImportSpec{
					Path: &ast.BasicLit{
						Kind:  token.STRING,
						Value: strconv.Quote("fmt"),
					},
				},
				&ast.ImportSpec{
					Path: &ast.BasicLit{
						Kind:  token.STRING,
						Value: strconv.Quote("strings"),
					},
				},
			},
		},
	}
	for _, decl := range file.Decls {
		d, err := genDecl(decl)
		if err != nil {
			return nil, err
		}
		decls = append(decls, d...)
	}
	return &ast.File{
		Decls: decls,
	}, nil
}

func genDecl(decl ir.Decl) ([]ast.Decl, error) {
	switch d := decl.(type) {
	case *ir.DataDecl:
		return genDataDecl(d)
	}
	return nil, fmt.Errorf("invalid declaration: %T", decl)
}

func genDataDecl(dataDecl *ir.DataDecl) ([]ast.Decl, error) {
	var decls []ast.Decl

	{
		tmpl, err := template.New("dataDeclTmpl").Parse(dataDeclTmpl)
		if err != nil {
			return nil, err
		}
		tagNames := make([]string, len(dataDecl.Conss)+1)
		tagNames[0] = ""
		for i, c := range dataDecl.Conss {
			tagNames[i+1] = c.Name
		}
		tyVarsStr := genSeq(dataDecl.TypeVarCount, "T", " Eqer", "", "")
		var caseTyVars string
		if tyVarsStr != "" {
			caseTyVars = "[" + tyVarsStr + ", U any]"
		} else {
			caseTyVars = "[U any]"
		}
		tyNamesStr := genSeq(dataDecl.TypeVarCount, "T", "", "", "")
		var caseTyNames string
		if tyNamesStr != "" {
			caseTyNames = "[" + tyNamesStr + ", U]"
		} else {
			caseTyNames = "[U]"
		}
		var b strings.Builder
		err = tmpl.Execute(&b, map[string]any{
			"DataName":            dataDecl.Name,
			"TyVarsWithType":      genTyVarWithType(dataDecl.TypeVarCount, "Eqer"),
			"TyVars":              genTyVars(dataDecl.TypeVarCount),
			"MatcherStructName":   "matcher_" + dataDecl.Name,
			"TagCount":            len(dataDecl.Conss),
			"TagNumToNameMapName": "tagNum2Name_" + dataDecl.Name,
			"TagNames":            tagNames,
			"CaseStructName":      "case_" + dataDecl.Name,
			"CaseTyVars":          caseTyVars,
			"CaseTyNames":         caseTyNames,
		})
		if err != nil {
			return nil, err
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, "", b.String(), 0)
		if err != nil {
			panic(err)
		}
		decls = append(decls, f.Decls...)
	}

	{
		tmpl, err := template.New("valConsDeclTmpl").Parse(valConsDeclTmpl)
		if err != nil {
			return nil, err
		}
		for i, valCons := range dataDecl.Conss {
			tagNum := i + 1
			fieldsStr, err := genFieldDecls(valCons.Params)
			if err != nil {
				return nil, err
			}
			paramsStr, err := genFieldsWithType(valCons.Params)
			if err != nil {
				return nil, err
			}
			var fieldsEqExprStr string
			if len(valCons.Params) > 0 {
				var b strings.Builder
				fmt.Fprintf(&b, "x.p1.Eq(z.p1)")
				for i := 2; i <= len(valCons.Params); i++ {
					fmt.Fprintf(&b, " && x.p%v.Eq(z.p%v)", i, i)
				}
				fieldsEqExprStr = b.String()
			}
			var b strings.Builder
			err = tmpl.Execute(&b, map[string]any{
				"DataName":           dataDecl.Name,
				"TagName":            valCons.Name,
				"TagNum":             tagNum,
				"TyVarsWithType":     genTyVarWithType(dataDecl.TypeVarCount, "Eqer"),
				"TyVars":             genTyVars(dataDecl.TypeVarCount),
				"Fields":             fieldsStr,
				"Params":             paramsStr,
				"KeyValuePairs":      genKeyValuePairs(valCons.Params),
				"MatcherStructName":  "matcher_" + dataDecl.Name,
				"TagStructName":      "tag_" + dataDecl.Name + "_" + valCons.Name,
				"MaybeTagStructName": "maybeTag_" + dataDecl.Name + "_" + valCons.Name,
				"HasFields":          len(valCons.Params) > 0,
				"FieldsEqExpr":       fieldsEqExprStr,
				"FieldsMethodReturn": genFields(len(valCons.Params), "x.x."),
			})
			if err != nil {
				return nil, err
			}

			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, "", b.String(), 0)
			if err != nil {
				panic(err)
			}
			decls = append(decls, f.Decls...)
		}
	}

	{
		tmpl, err := template.New("dataAssociatedTmpl").Parse(dataAssociatedTmpl)
		if err != nil {
			return nil, err
		}
		for _, valCons := range dataDecl.Conss {
			paramStrs := make([]string, len(valCons.Params))
			for i, p := range valCons.Params {
				s, err := genType(p)
				if err != nil {
					return nil, err
				}
				paramStrs[i] = s
			}

			tyVarsStr := genSeq(dataDecl.TypeVarCount, "T", " Eqer", "", "")
			var applyTyVars string
			if tyVarsStr != "" {
				applyTyVars = "[" + tyVarsStr + ", U any]"
			} else {
				applyTyVars = "[U any]"
			}

			tyNamesStr := genSeq(dataDecl.TypeVarCount, "T", "", "", "")
			var applyTyNames string
			if tyNamesStr != "" {
				applyTyNames = "[" + tyNamesStr + ", U]"
			} else {
				applyTyNames = "[U]"
			}

			var b strings.Builder
			err = tmpl.Execute(&b, map[string]any{
				"DataName":            dataDecl.Name,
				"DataTyVars":          genSeq(dataDecl.TypeVarCount, "T", "", "[", "]"),
				"CaseStructName":      "case_" + dataDecl.Name,
				"ApplyTyVars":         applyTyVars,
				"ApplyTyNames":        applyTyNames,
				"TagName":             valCons.Name,
				"ApplyCallbackParams": strings.Join(paramStrs, ","),
				"HasFields":           len(valCons.Params) > 0,
				"Fields":              genFields(len(valCons.Params), ""),
			})
			if err != nil {
				return nil, err
			}

			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, "", b.String(), 0)
			if err != nil {
				panic(err)
			}
			decls = append(decls, f.Decls...)
		}
	}

	return decls, nil
}

// {prefix}1{suffix}, {prefix}2{suffix}, ..., {prefix}n{suffix}
func genSeq(n int, prefix, suffix string, l, r string) string {
	if n == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprint(&b, l)
	fmt.Fprintf(&b, "%v1%v", prefix, suffix)
	for i := 2; i <= n; i++ {
		fmt.Fprintf(&b, ", %v%v%v", prefix, i, suffix)
	}
	fmt.Fprint(&b, r)
	return b.String()
}

// [T1, T2, ...]
func genTyVars(tyVarCount int) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1")
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v", i)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// [T1 {ty}, T2 {ty}, ...]
func genTyVarWithType(tyVarCount int, ty string) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1 %v", ty)
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v %v", i, ty)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// p1 {T}
// p2 {T}
// ...
func genFieldDecls(tys []ir.Type) (string, error) {
	var b strings.Builder
	for i, p := range tys {
		ty, err := genType(p)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "p%v %v\n", i+1, ty)
	}
	return b.String(), nil
}

// {prefix}p1, {prefix}p2, ...
func genFields(fieldCount int, prefix string) string {
	if fieldCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "%vp1", prefix)
	for i := 2; i <= fieldCount; i++ {
		fmt.Fprintf(&b, ", %vp%v", prefix, i)
	}
	return b.String()
}

// p1 {T}, p2 {T}, ...
func genFieldsWithType(tys []ir.Type) (string, error) {
	if len(tys) == 0 {
		return "", nil
	}
	var b strings.Builder
	ty, err := genType(tys[0])
	if err != nil {
		return "", err
	}
	fmt.Fprintf(&b, "p1 %v", ty)
	for i, p := range tys[1:] {
		ty, err := genType(p)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, ", p%v %v", i+2, ty)
	}
	return b.String(), nil
}

// p1: {T},
// p2: {T},
// ...
func genKeyValuePairs(tys []ir.Type) string {
	var b strings.Builder
	for i := 1; i <= len(tys); i++ {
		fmt.Fprintf(&b, "p%v: p%v,\n", i, i)
	}
	return b.String()
}

func genType(ty ir.Type) (string, error) {
	switch t := ty.(type) {
	case *ir.BasicType:
		return t.Name, nil
	case *ir.NamedType:
		return t.Name, nil
	case *ir.ConcreteType:
		var b strings.Builder
		abTy, err := genType(t.AbstractTy)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "%v", abTy)
		argTy, err := genType(t.Args[0])
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "[%v", argTy)
		for _, arg := range t.Args[1:] {
			argTy, err := genType(arg)
			if err != nil {
				return "", err
			}
			fmt.Fprintf(&b, ", %v", argTy)
		}
		fmt.Fprint(&b, "]")
		return b.String(), nil
	case *ir.TypeVar:
		return "T" + strconv.Itoa(t.Num), nil
	}
	return "", fmt.Errorf("invalid type: %T", ty)
}

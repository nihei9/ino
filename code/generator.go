package code

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strconv"

	"github.com/nihei9/ino/ir"
)

type CodeGenerator struct {
	PkgName string
	Out     io.Writer
}

func (g *CodeGenerator) Run(file *ir.File) error {
	f, err := genFile(file)
	if err != nil {
		return err
	}
	f.Name = ast.NewIdent(g.PkgName)
	fmt.Fprintln(g.Out, "// Code generated by ino. DO NOT EDIT.")
	err = format.Node(g.Out, token.NewFileSet(), f)
	if err != nil {
		return err
	}
	return nil
}

func genFile(file *ir.File) (*ast.File, error) {
	var decls []ast.Decl
	for _, decl := range file.Decls {
		d, err := genDecl(decl)
		if err != nil {
			return nil, err
		}
		decls = append(decls, d...)
	}
	return &ast.File{
		Decls: decls,
	}, nil
}

func genDecl(decl ir.Decl) ([]ast.Decl, error) {
	switch d := decl.(type) {
	case *ir.FuncDecl:
		return genFuncDecl(d)
	case *ir.DataDecl:
		return genDataDecl(d)
	case *ir.ValConsDecl:
		return genValConsDecl(d)
	}
	return nil, fmt.Errorf("invalid declaration: %T", decl)
}

func genFuncDecl(d *ir.FuncDecl) ([]ast.Decl, error) {
	params := make([]*ast.Field, len(d.Params))
	for i, p := range d.Params {
		pTy, err := genType(p.Ty)
		if err != nil {
			return nil, err
		}
		params[i] = newField(newID(p.Name), pTy)
	}
	rTy, err := genType(d.Result)
	if err != nil {
		return nil, err
	}
	expr, err := genExpr(d.Body)
	if err != nil {
		return nil, err
	}
	return []ast.Decl{
		newFuncDecl(
			ast.NewIdent(d.Name),
			newFieldList(
				params...),
			newFieldList(
				newField(nil, rTy)),
			newBlockStmt(
				newReturnStmt(expr)),
		),
	}, nil
}

func genDataDecl(d *ir.DataDecl) ([]ast.Decl, error) {
	// type Xxx interface {
	//     Maybe() *matcher_Xxx
	// }
	dataStruct := newInterfaceDecl(
		newID(d.Name),
		newFieldList(
			newField(
				newID("Maybe"),
				newFuncType(nil, newFieldList(
					newField(nil, newStarExpr(newID("matcher_"+d.Name))),
				))),
		))

	// type matcher_Xxx struct {
	//     x Xxx
	// }
	matcherStruct := newStructDecl(
		newID("matcher_"+d.Name),
		newFieldList(
			newField(newID("x"), newID(d.Name)),
		))

	return []ast.Decl{
		dataStruct,
		matcherStruct,
	}, nil
}

func genValConsDecl(d *ir.ValConsDecl) ([]ast.Decl, error) {
	tagName := newID("tag_" + d.TyName + "_" + d.Name)

	// type tag_Xxx_Aaa struct {
	//     p1 ty1
	//     p2 ty2
	//     ..
	//     pN tyN
	// }
	consFields := make([]*ast.Field, len(d.Params))
	for i, p := range d.Params {
		pTy, err := genType(p)
		if err != nil {
			return nil, err
		}
		consFields[i] = newField(newID("p"+strconv.Itoa(i+1)), pTy)
	}
	consStruct := newStructDecl(
		tagName,
		newFieldList(consFields...))

	// func Aaa(p1 ty1, p2 ty2, ..., pN tyN) Xxx {
	//     return &tag_Xxx_Aaa{
	//         p1: p1,
	//         p2: p2,
	//         ...
	//         pN: pN,
	//     }
	// }
	kvs := make([]ast.Expr, len(consFields))
	for i, f := range consFields {
		kvs[i] = newKeyValueExpr(f.Names[0], f.Names[0])
	}
	consFunc := newFuncDecl(
		newID(d.Name),
		newFieldList(consFields...),
		newFieldList(
			newField(nil, newID(d.TyName))),
		newBlockStmt(
			newReturnStmt(
				newRefExpr(newCompositLit(tagName, kvs...)))))

	// func (x *Aaa) Maybe() *matcher_Xxx {
	//     return &matcher_Xxx{
	//         x: x,
	//     }
	// }
	maybeMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(newID(d.Name)))),
		newID("Maybe"),
		nil,
		newFieldList(
			newField(nil, newID("matcher_"+d.TyName))),
		newBlockStmt(
			newReturnStmt(
				newRefExpr(newCompositLit(
					newID("matcher_"+d.TyName),
					newKeyValueExpr(newID("x"), newID("x")))))))

	// func (x *matcher_Xxx) Aaa() maybe_tag_Xxx_Aaa {
	//     if y, ok := x.x.(*tag_Xxx_Aaa); ok {
	//         return &maybe_tag_Xxx_Aaa{
	//             x: y,
	//         }
	//     }
	//     return &maybe_tag_Xxx_Aaa{}
	// }
	consMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(newID("matcher_"+d.TyName))),
		),
		newID(d.Name),
		nil,
		newFieldList(
			newField(nil, newID("maybe_tag_"+d.TyName+"_"+d.Name)),
		),
		newBlockStmt(
			newIfStmt(
				newDefineStmt(
					[]ast.Expr{newID("y"), newID("ok")},
					[]ast.Expr{
						newTypeAssertExpr(
							newSelectorExpr(newID("x"), newID("x")),
							newStarExpr(tagName)),
					},
				),
				ast.NewIdent("ok"),
				newBlockStmt(
					newReturnStmt(
						newRefExpr(
							newCompositLit(
								newID("maybe_tag_"+d.TyName+"_"+d.Name),
								newKeyValueExpr(ast.NewIdent("x"), ast.NewIdent("y"))))))),
			newReturnStmt(
				newRefExpr(
					newCompositLit(
						ast.NewIdent("maybe_tag_"+d.TyName+"_"+d.Name))))))

	// type maybe_tag_Xxx_Aaa struct {
	//     x *tag_Xxx_Aaa
	// }
	maybeStruct := newStructDecl(
		newID("maybe_tag_"+d.TyName+"_"+d.Name),
		newFieldList(
			newField(newID("x"), newStarExpr(tagName))))

	// func (x *maybe_tag_Xxx_Aaa) OK() bool {
	//     return x.x != nil
	// }
	OKMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(newID("maybe_tag_"+d.TyName+"_"+d.Name)))),
		newID("OK"),
		nil,
		newFieldList(
			newField(nil, newID("bool"))),
		newBlockStmt(
			newReturnStmt(
				newBinaryExpr(
					token.NEQ,
					newSelectorExpr(ast.NewIdent("x"), ast.NewIdent("x")),
					ast.NewIdent("nil")))))
	return []ast.Decl{
		consStruct,
		consFunc,
		maybeMethod,
		consMethod,
		maybeStruct,
		OKMethod,
	}, nil
}

func genExpr(expr ir.Expr) (ast.Expr, error) {
	switch e := expr.(type) {
	case *ir.IntLit:
		return &ast.BasicLit{
			Kind:  token.INT,
			Value: strconv.Itoa(e.Val),
		}, nil
	case *ir.StringLit:
		return &ast.BasicLit{
			Kind:  token.STRING,
			Value: e.Val,
		}, nil
	case *ir.IdentExpr:
		if e.Constant {
			return &ast.CallExpr{
				Fun: newID(e.Ident),
			}, nil
		}
		return ast.NewIdent(e.Ident), nil
	case *ir.CallExpr:
		return genCallExpr(e)
	case *ir.BinaryExpr:
		return genBinaryExpr(e)
	}
	return nil, fmt.Errorf("invalid expression type: %T", expr)
}

func genCallExpr(call *ir.CallExpr) (ast.Expr, error) {
	fun, err := genExpr(call.Func)
	if err != nil {
		return nil, err
	}
	args := make([]ast.Expr, len(call.Args))
	for i, arg := range call.Args {
		a, err := genExpr(arg)
		if err != nil {
			return nil, err
		}
		args[i] = a
	}
	return &ast.CallExpr{
		Fun:  fun,
		Args: args,
	}, nil
}

func genBinaryExpr(bin *ir.BinaryExpr) (ast.Expr, error) {
	lhs, err := genExpr(bin.LHS)
	if err != nil {
		return nil, err
	}
	op, err := genBinOp(bin.Op)
	if err != nil {
		return nil, err
	}
	rhs, err := genExpr(bin.RHS)
	if err != nil {
		return nil, err
	}
	return newBinaryExpr(op, lhs, rhs), nil
}

func genType(ty ir.Type) (ast.Expr, error) {
	switch t := ty.(type) {
	case *ir.BasicType:
		return ast.NewIdent(t.Name), nil
	case *ir.NamedType:
		return ast.NewIdent(t.Name), nil
	}
	return nil, fmt.Errorf("invalid type: %T", ty)
}

func genBinOp(op ir.BinOp) (token.Token, error) {
	switch op {
	case ir.OpAdd:
		return token.ADD, nil
	case ir.OpSub:
		return token.SUB, nil
	case ir.OpMul:
		return token.MUL, nil
	case ir.OpDiv:
		return token.QUO, nil
	case ir.OpMod:
		return token.REM, nil
	}
	return token.ILLEGAL, fmt.Errorf("invalid binary operator: %v", op)
}

func newInterfaceDecl(name *ast.Ident, fields *ast.FieldList) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: name,
				Type: &ast.InterfaceType{
					Methods: fields,
				},
			},
		},
	}
}

func newStructDecl(name *ast.Ident, fields *ast.FieldList) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: name,
				Type: &ast.StructType{
					Fields: fields,
				},
			},
		},
	}
}

func newFuncDecl(name *ast.Ident, params *ast.FieldList, results *ast.FieldList, body *ast.BlockStmt) *ast.FuncDecl {
	return newMethodDecl(nil, name, params, results, body)
}

func newMethodDecl(recv *ast.FieldList, name *ast.Ident, params *ast.FieldList, results *ast.FieldList, body *ast.BlockStmt) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: recv,
		Name: name,
		Type: &ast.FuncType{
			Params:  params,
			Results: results,
		},
		Body: body,
	}
}

func newFieldList(fields ...*ast.Field) *ast.FieldList {
	if fields == nil {
		fields = []*ast.Field{}
	}
	return &ast.FieldList{
		List: fields,
	}
}

func newField(name *ast.Ident, ty ast.Expr) *ast.Field {
	var names []*ast.Ident
	if name != nil {
		names = append(names, name)
	}
	return &ast.Field{
		Names: names,
		Type:  ty,
	}
}

func newBlockStmt(stmts ...ast.Stmt) *ast.BlockStmt {
	return &ast.BlockStmt{
		List: stmts,
	}
}

func newIfStmt(init ast.Stmt, cond ast.Expr, body *ast.BlockStmt) *ast.IfStmt {
	return &ast.IfStmt{
		Init: init,
		Cond: cond,
		Body: body,
	}
}

func newDefineStmt(lhs []ast.Expr, rhs []ast.Expr) *ast.AssignStmt {
	return &ast.AssignStmt{
		Lhs: lhs,
		Tok: token.DEFINE,
		Rhs: rhs,
	}
}

func newReturnStmt(results ...ast.Expr) *ast.ReturnStmt {
	return &ast.ReturnStmt{
		Results: results,
	}
}

func newFuncType(params *ast.FieldList, results *ast.FieldList) *ast.FuncType {
	return &ast.FuncType{
		Params:  params,
		Results: results,
	}
}

func newStarExpr(x ast.Expr) *ast.StarExpr {
	return &ast.StarExpr{
		X: x,
	}
}

func newRefExpr(x ast.Expr) *ast.UnaryExpr {
	return &ast.UnaryExpr{
		Op: token.AND,
		X:  x,
	}
}

func newSelectorExpr(x ast.Expr, sel *ast.Ident) *ast.SelectorExpr {
	return &ast.SelectorExpr{
		X:   x,
		Sel: sel,
	}
}

func newCompositLit(ty ast.Expr, elts ...ast.Expr) *ast.CompositeLit {
	return &ast.CompositeLit{
		Type: ty,
		Elts: elts,
	}
}

func newKeyValueExpr(key ast.Expr, value ast.Expr) *ast.KeyValueExpr {
	return &ast.KeyValueExpr{
		Key:   key,
		Value: value,
	}
}

func newID(id string) *ast.Ident {
	return ast.NewIdent(id)
}

func newBinaryExpr(op token.Token, lhs ast.Expr, rhs ast.Expr) *ast.BinaryExpr {
	return &ast.BinaryExpr{
		X:  lhs,
		Op: op,
		Y:  rhs,
	}
}

func newTypeAssertExpr(x ast.Expr, ty ast.Expr) *ast.TypeAssertExpr {
	return &ast.TypeAssertExpr{
		X:    x,
		Type: ty,
	}
}

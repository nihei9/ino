package code

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strconv"

	"github.com/nihei9/ino/ir"
)

type CodeGenerator struct {
	PkgName string
	Out     io.Writer
}

func (g *CodeGenerator) Run(file *ir.File) error {
	f, err := genFile(file)
	if err != nil {
		return err
	}
	f.Name = ast.NewIdent(g.PkgName)
	fmt.Fprintln(g.Out, "// Code generated by ino. DO NOT EDIT.")
	err = format.Node(g.Out, token.NewFileSet(), f)
	if err != nil {
		return err
	}
	return nil
}

func genFile(file *ir.File) (*ast.File, error) {
	var decls []ast.Decl
	for _, decl := range file.Decls {
		d, err := genDecl(decl)
		if err != nil {
			return nil, err
		}
		decls = append(decls, d...)
	}
	return &ast.File{
		Decls: decls,
	}, nil
}

func genDecl(decl ir.Decl) ([]ast.Decl, error) {
	switch d := decl.(type) {
	case *ir.DataDecl:
		return genDataDecl(d)
	case *ir.ValConsDecl:
		return genValConsDecl(d)
	}
	return nil, fmt.Errorf("invalid declaration: %T", decl)
}

func genDataDecl(d *ir.DataDecl) ([]ast.Decl, error) {
	matcherStructIdent := newID("matcher_" + d.Name)

	// type Xxx interface {
	//     Maybe() *matcher_Xxx
	// }
	dataStruct := newInterfaceDecl(
		newID(d.Name),
		newFieldList(
			newField(
				newID("Maybe"),
				newFuncType(nil, newFieldList(
					newField(nil, newStarExpr(matcherStructIdent)),
				))),
		))

	// type matcher_Xxx struct {
	//     x Xxx
	// }
	matcherStruct := newStructDecl(
		matcherStructIdent,
		newFieldList(
			newField(newID("x"), newID(d.Name)),
		))

	return []ast.Decl{
		dataStruct,
		matcherStruct,
	}, nil
}

func genValConsDecl(d *ir.ValConsDecl) ([]ast.Decl, error) {
	tagStructIdent := newID("tag_" + d.TyName + "_" + d.Name)
	matcherStructIdent := newID("matcher_" + d.TyName)
	maybeTagStructIdent := newID("maybeTag_" + d.TyName + "_" + d.Name)

	// type tag_Xxx_Aaa struct {
	//     p1 ty1
	//     p2 ty2
	//     ..
	//     pN tyN
	// }
	consFields := make([]*ast.Field, len(d.Params))
	for i, p := range d.Params {
		pTy, err := genType(p)
		if err != nil {
			return nil, err
		}
		consFields[i] = newField(newID("p"+strconv.Itoa(i+1)), pTy)
	}
	consStruct := newStructDecl(
		tagStructIdent,
		newFieldList(consFields...))

	// func Aaa(p1 ty1, p2 ty2, ..., pN tyN) Xxx {
	//     return &tag_Xxx_Aaa{
	//         p1: p1,
	//         p2: p2,
	//         ...
	//         pN: pN,
	//     }
	// }
	kvs := make([]ast.Expr, len(consFields))
	for i, f := range consFields {
		kvs[i] = newKeyValueExpr(f.Names[0], f.Names[0])
	}
	consFunc := newFuncDecl(
		newID(d.Name),
		newFieldList(consFields...),
		newFieldList(
			newField(nil, newID(d.TyName))),
		newBlockStmt(
			newReturnStmt(
				newRefExpr(newCompositLit(tagStructIdent, kvs...)))))

	// func (x *tag_Xxx_Aaa) Maybe() *matcher_Xxx {
	//     return &matcher_Xxx{
	//         x: x,
	//     }
	// }
	maybeMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(tagStructIdent))),
		newID("Maybe"),
		nil,
		newFieldList(
			newField(nil, newStarExpr(matcherStructIdent))),
		newBlockStmt(
			newReturnStmt(
				newRefExpr(newCompositLit(
					matcherStructIdent,
					newKeyValueExpr(newID("x"), newID("x")))))))

	// func (x *matcher_Xxx) Aaa() maybeTag_Xxx_Aaa {
	//     if y, ok := x.x.(*tag_Xxx_Aaa); ok {
	//         return &maybeTag_Xxx_Aaa{
	//             x: y,
	//         }
	//     }
	//     return &maybeTag_Xxx_Aaa{}
	// }
	consMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(matcherStructIdent)),
		),
		newID(d.Name),
		nil,
		newFieldList(
			newField(nil, newStarExpr(maybeTagStructIdent)),
		),
		newBlockStmt(
			newIfStmt(
				newDefineStmt(
					[]ast.Expr{newID("y"), newID("ok")},
					[]ast.Expr{
						newTypeAssertExpr(
							newSelectorExpr(newID("x"), newID("x")),
							newStarExpr(tagStructIdent)),
					},
				),
				ast.NewIdent("ok"),
				newBlockStmt(
					newReturnStmt(
						newRefExpr(
							newCompositLit(
								maybeTagStructIdent,
								newKeyValueExpr(ast.NewIdent("x"), ast.NewIdent("y"))))))),
			newReturnStmt(
				newRefExpr(
					newCompositLit(maybeTagStructIdent)))))

	// type maybeTag_Xxx_Aaa struct {
	//     x *tag_Xxx_Aaa
	// }
	maybeStruct := newStructDecl(
		maybeTagStructIdent,
		newFieldList(
			newField(newID("x"), newStarExpr(tagStructIdent))))

	// func (x *maybeTag_Xxx_Aaa) OK() bool {
	//     return x.x != nil
	// }
	okMethod := newMethodDecl(
		newFieldList(
			newField(newID("x"), newStarExpr(maybeTagStructIdent))),
		newID("OK"),
		nil,
		newFieldList(
			newField(nil, newID("bool"))),
		newBlockStmt(
			newReturnStmt(
				newBinaryExpr(
					token.NEQ,
					newSelectorExpr(ast.NewIdent("x"), ast.NewIdent("x")),
					ast.NewIdent("nil")))))

	decls := []ast.Decl{
		consStruct,
		consFunc,
		maybeMethod,
		consMethod,
		maybeStruct,
		okMethod,
	}

	if len(d.Params) == 0 {
		return decls, nil
	}

	// func (x *maybeTag_Xxx_Aaa) Fields() (p1 T1, p2 T2, ..., ok bool) {
	//     if !x.OK() {
	//         return
	//     }
	//     return x.x.p1, x.x.p2, ..., true
	// }
	var fieldsMethod *ast.FuncDecl
	{
		var results *ast.FieldList
		var returnVals []ast.Expr
		var zeroVarDecls []ast.Stmt
		var zeroReturnVals []ast.Expr
		{
			resultLen := len(d.Params) + 1
			fields := make([]*ast.Field, resultLen)
			returnVals = make([]ast.Expr, resultLen)
			zeroVarDecls = make([]ast.Stmt, resultLen)
			zeroReturnVals = make([]ast.Expr, resultLen)
			for i, p := range d.Params {
				ty, err := genType(p)
				if err != nil {
					return nil, err
				}
				fieldName := newID("p" + strconv.Itoa(i+1))
				zeroVarName := newID("z" + strconv.Itoa(i+1))
				fields[i] = newField(fieldName, ty)
				returnVals[i] = newSelectorExpr(
					newSelectorExpr(newID("x"), newID("x")), fieldName)
				zeroVarDecls[i] = &ast.DeclStmt{
					Decl: &ast.GenDecl{
						Tok: token.VAR,
						Specs: []ast.Spec{
							&ast.ValueSpec{
								Names: []*ast.Ident{
									zeroVarName,
								},
								Type: ty,
							},
						},
					},
				}
				zeroReturnVals[i] = zeroVarName
			}
			fields[resultLen-1] = newField(newID("ok"), newID("bool"))
			results = newFieldList(fields...)
			returnVals[resultLen-1] = newID("true")
			zeroVarDecls[resultLen-1] = &ast.DeclStmt{
				Decl: &ast.GenDecl{
					Tok: token.VAR,
					Specs: []ast.Spec{
						&ast.ValueSpec{
							Names: []*ast.Ident{
								newID("ok"),
							},
							Type: newID("bool"),
						},
					},
				},
			}
			zeroReturnVals[resultLen-1] = newID("ok")
		}

		var notOKStmts []ast.Stmt
		notOKStmts = append(notOKStmts, zeroVarDecls...)
		notOKStmts = append(notOKStmts, newReturnStmt(zeroReturnVals...))
		fieldsMethod = newMethodDecl(
			newFieldList(
				newField(newID("x"), newStarExpr(maybeTagStructIdent))),
			newID("Fields"),
			nil,
			results,
			newBlockStmt(
				newIfStmt(
					nil,
					newNotExpr(
						newCallExpr(
							newSelectorExpr(newID("x"), newID("OK")),
							nil)),
					newBlockStmt(
						notOKStmts...)),
				newReturnStmt(returnVals...)))
	}
	decls = append(decls, fieldsMethod)

	return decls, nil
}

func genType(ty ir.Type) (ast.Expr, error) {
	switch t := ty.(type) {
	case *ir.BasicType:
		return ast.NewIdent(t.Name), nil
	case *ir.NamedType:
		return ast.NewIdent(t.Name), nil
	}
	return nil, fmt.Errorf("invalid type: %T", ty)
}

func newInterfaceDecl(name *ast.Ident, fields *ast.FieldList) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: name,
				Type: &ast.InterfaceType{
					Methods: fields,
				},
			},
		},
	}
}

func newStructDecl(name *ast.Ident, fields *ast.FieldList) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: name,
				Type: &ast.StructType{
					Fields: fields,
				},
			},
		},
	}
}

func newFuncDecl(name *ast.Ident, params *ast.FieldList, results *ast.FieldList, body *ast.BlockStmt) *ast.FuncDecl {
	return newMethodDecl(nil, name, params, results, body)
}

func newMethodDecl(recv *ast.FieldList, name *ast.Ident, params *ast.FieldList, results *ast.FieldList, body *ast.BlockStmt) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: recv,
		Name: name,
		Type: &ast.FuncType{
			Params:  params,
			Results: results,
		},
		Body: body,
	}
}

func newFieldList(fields ...*ast.Field) *ast.FieldList {
	if fields == nil {
		fields = []*ast.Field{}
	}
	return &ast.FieldList{
		List: fields,
	}
}

func newField(name *ast.Ident, ty ast.Expr) *ast.Field {
	var names []*ast.Ident
	if name != nil {
		names = append(names, name)
	}
	return &ast.Field{
		Names: names,
		Type:  ty,
	}
}

func newBlockStmt(stmts ...ast.Stmt) *ast.BlockStmt {
	return &ast.BlockStmt{
		List: stmts,
	}
}

func newIfStmt(init ast.Stmt, cond ast.Expr, body *ast.BlockStmt) *ast.IfStmt {
	return &ast.IfStmt{
		Init: init,
		Cond: cond,
		Body: body,
	}
}

func newDefineStmt(lhs []ast.Expr, rhs []ast.Expr) *ast.AssignStmt {
	return &ast.AssignStmt{
		Lhs: lhs,
		Tok: token.DEFINE,
		Rhs: rhs,
	}
}

func newReturnStmt(results ...ast.Expr) *ast.ReturnStmt {
	if len(results) == 0 {
		return &ast.ReturnStmt{}
	}
	return &ast.ReturnStmt{
		Results: results,
	}
}

func newFuncType(params *ast.FieldList, results *ast.FieldList) *ast.FuncType {
	return &ast.FuncType{
		Params:  params,
		Results: results,
	}
}

func newStarExpr(x ast.Expr) *ast.StarExpr {
	return &ast.StarExpr{
		X: x,
	}
}

func newRefExpr(x ast.Expr) *ast.UnaryExpr {
	return &ast.UnaryExpr{
		Op: token.AND,
		X:  x,
	}
}

func newSelectorExpr(x ast.Expr, sel *ast.Ident) *ast.SelectorExpr {
	return &ast.SelectorExpr{
		X:   x,
		Sel: sel,
	}
}

func newCompositLit(ty ast.Expr, elts ...ast.Expr) *ast.CompositeLit {
	return &ast.CompositeLit{
		Type: ty,
		Elts: elts,
	}
}

func newKeyValueExpr(key ast.Expr, value ast.Expr) *ast.KeyValueExpr {
	return &ast.KeyValueExpr{
		Key:   key,
		Value: value,
	}
}

func newID(id string) *ast.Ident {
	return ast.NewIdent(id)
}

func newBinaryExpr(op token.Token, lhs ast.Expr, rhs ast.Expr) *ast.BinaryExpr {
	return &ast.BinaryExpr{
		X:  lhs,
		Op: op,
		Y:  rhs,
	}
}

func newNotExpr(x ast.Expr) *ast.UnaryExpr {
	return &ast.UnaryExpr{
		Op: token.NOT,
		X:  x,
	}
}

func newCallExpr(fun ast.Expr, args []ast.Expr) *ast.CallExpr {
	return &ast.CallExpr{
		Fun:  fun,
		Args: args,
	}
}

func newTypeAssertExpr(x ast.Expr, ty ast.Expr) *ast.TypeAssertExpr {
	return &ast.TypeAssertExpr{
		X:    x,
		Type: ty,
	}
}

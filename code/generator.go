package code

import (
	_ "embed"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/nihei9/ino/ir"
)

var (
	//go:embed builtin.tmpl
	builtinTmpl string

	//go:embed data_decl.tmpl
	dataDeclTmpl string
)

type CodeGenerator struct {
	PkgName     string
	OutDir      string
	OutFileName string
}

func (g *CodeGenerator) Run(file *ir.File) error {
	var b strings.Builder
	fmt.Fprintln(&b, "// Code generated by ino. DO NOT EDIT.")
	fmt.Fprintln(&b, "package", g.PkgName)
	err := genFile(&b, file)
	if err != nil {
		return err
	}
	outFilePath := filepath.Join(g.OutDir, g.OutFileName)
	out, err := os.OpenFile(outFilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer out.Close()
	_, err = out.WriteString(b.String())
	if err != nil {
		return err
	}

	{
		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, "", builtinTmpl, 0)
		if err != nil {
			panic(err)
		}
		outFilePath := filepath.Join(g.OutDir, "ino_builtin.go")
		out, err := os.OpenFile(outFilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
		defer out.Close()
		f.Name = ast.NewIdent(g.PkgName)
		fmt.Fprintln(out, "// Code generated by ino. DO NOT EDIT.")
		err = format.Node(out, token.NewFileSet(), f)
		if err != nil {
			return err
		}
	}

	return nil
}

func genFile(w io.Writer, file *ir.File) error {
	fmt.Fprint(w, `
import (
	"fmt"
	"strings"
)

`)
	for _, decl := range file.Decls {
		err := genDecl(w, decl)
		if err != nil {
			return err
		}
	}
	return nil
}

func genDecl(w io.Writer, decl ir.Decl) error {
	switch d := decl.(type) {
	case *ir.DataDecl:
		return genDataDecl(w, d)
	}
	return fmt.Errorf("invalid declaration: %T", decl)
}

func genDataDecl(w io.Writer, dataDecl *ir.DataDecl) error {
	m, err := genDataMap(dataDecl)
	if err != nil {
		return err
	}
	tmpl, err := template.New("dataDeclTmpl").Parse(dataDeclTmpl)
	if err != nil {
		return err
	}
	var b strings.Builder
	err = tmpl.Execute(&b, m)
	if err != nil {
		return err
	}
	fmt.Fprintln(w, b.String())

	return nil
}

func genDataMap(dataDecl *ir.DataDecl) (map[string]any, error) {
	valConss := make([]map[string]any, len(dataDecl.Conss))
	for i, cons := range dataDecl.Conss {
		tagNum := i + 1
		fields := make([]string, len(cons.Params))
		for i, p := range cons.Params {
			ty, err := genType(p)
			if err != nil {
				return nil, err
			}
			fields[i] = fmt.Sprintf("p%v %v", i+1, ty)
		}
		var fieldsEqExpr string
		if len(cons.Params) > 0 {
			var b strings.Builder
			fmt.Fprintf(&b, "x.p1.Eq(z.p1)")
			for i := 2; i <= len(cons.Params); i++ {
				fmt.Fprintf(&b, " && x.p%v.Eq(z.p%v)", i, i)
			}
			fieldsEqExpr = b.String()
		}
		params, err := genFieldsWithType(cons.Params)
		if err != nil {
			return nil, err
		}
		paramStrs := make([]string, len(cons.Params))
		for i, p := range cons.Params {
			s, err := genType(p)
			if err != nil {
				return nil, err
			}
			paramStrs[i] = s
		}
		keyValuePairs := make([]string, len(cons.Params))
		for i := 0; i < len(cons.Params); i++ {
			keyValuePairs[i] = fmt.Sprintf("p%v: p%v,", i+1, i+1)
		}
		var applyTyVars string
		{
			tyVarsStr := genSeq(dataDecl.TypeVarCount, "T", " Eqer", "", "")
			if tyVarsStr != "" {
				applyTyVars = "[" + tyVarsStr + ", U any]"
			} else {
				applyTyVars = "[U any]"
			}
		}
		var applyTyNames string
		{
			tyNamesStr := genSeq(dataDecl.TypeVarCount, "T", "", "", "")
			if tyNamesStr != "" {
				applyTyNames = "[" + tyNamesStr + ", U]"
			} else {
				applyTyNames = "[U]"
			}
		}
		valConss[i] = map[string]any{
			"TagName":             cons.Name,
			"TagNum":              tagNum,
			"TagStructName":       "tag_" + dataDecl.Name + "_" + cons.Name,
			"MaybeTagStructName":  "maybeTag_" + dataDecl.Name + "_" + cons.Name,
			"HasFields":           len(cons.Params) > 0,
			"Fields":              fields,
			"FieldsEqExpr":        fieldsEqExpr,
			"FieldsMethodReturn":  genFields(len(cons.Params), "x.x."),
			"FieldSeq":            genFields(len(cons.Params), ""),
			"Params":              params,
			"KeyValuePairs":       keyValuePairs,
			"ApplyToFuncName":     "ApplyTo" + cons.Name,
			"ApplyTyVars":         applyTyVars,
			"ApplyTyNames":        applyTyNames,
			"ApplyCallbackParams": strings.Join(paramStrs, ","),
			"CaseFuncName":        "Case" + cons.Name,
		}
	}
	tagNames := make([]string, len(dataDecl.Conss)+1)
	tagNames[0] = ""
	for i, c := range dataDecl.Conss {
		tagNames[i+1] = c.Name
	}
	tyVarsStr := genSeq(dataDecl.TypeVarCount, "T", " Eqer", "", "")
	var caseTyVars string
	if tyVarsStr != "" {
		caseTyVars = "[" + tyVarsStr + ", U any]"
	} else {
		caseTyVars = "[U any]"
	}
	tyNamesStr := genSeq(dataDecl.TypeVarCount, "T", "", "", "")
	var caseTyNames string
	if tyNamesStr != "" {
		caseTyNames = "[" + tyNamesStr + ", U]"
	} else {
		caseTyNames = "[U]"
	}

	return map[string]any{
		"DataName":            dataDecl.Name,
		"TyVarsWithType":      genTyVarWithType(dataDecl.TypeVarCount, "Eqer"),
		"TyVars":              genTyVars(dataDecl.TypeVarCount),
		"DataTyVars":          genSeq(dataDecl.TypeVarCount, "T", "", "[", "]"),
		"MatcherStructName":   "matcher_" + dataDecl.Name,
		"TagCount":            len(dataDecl.Conss),
		"TagNumToNameMapName": "tagNum2Name_" + dataDecl.Name,
		"TagNames":            tagNames,
		"CaseSetStructName":   dataDecl.Name + "CaseSet",
		"NewCaseSetFuncName":  "New" + dataDecl.Name + "CaseSet",
		"CaseStructName":      "case_" + dataDecl.Name,
		"CaseTyVars":          caseTyVars,
		"CaseTyNames":         caseTyNames,
		"DefaultCaseFuncName": "Case" + dataDecl.Name + "Default",
		"ValConss":            valConss,
	}, nil
}

// {prefix}1{suffix}, {prefix}2{suffix}, ..., {prefix}n{suffix}
func genSeq(n int, prefix, suffix string, l, r string) string {
	if n == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprint(&b, l)
	fmt.Fprintf(&b, "%v1%v", prefix, suffix)
	for i := 2; i <= n; i++ {
		fmt.Fprintf(&b, ", %v%v%v", prefix, i, suffix)
	}
	fmt.Fprint(&b, r)
	return b.String()
}

// [T1, T2, ...]
func genTyVars(tyVarCount int) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1")
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v", i)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// [T1 {ty}, T2 {ty}, ...]
func genTyVarWithType(tyVarCount int, ty string) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1 %v", ty)
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v %v", i, ty)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// {prefix}p1, {prefix}p2, ...
func genFields(fieldCount int, prefix string) string {
	if fieldCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "%vp1", prefix)
	for i := 2; i <= fieldCount; i++ {
		fmt.Fprintf(&b, ", %vp%v", prefix, i)
	}
	return b.String()
}

// p1 {T}, p2 {T}, ...
func genFieldsWithType(tys []ir.Type) (string, error) {
	if len(tys) == 0 {
		return "", nil
	}
	var b strings.Builder
	ty, err := genType(tys[0])
	if err != nil {
		return "", err
	}
	fmt.Fprintf(&b, "p1 %v", ty)
	for i, p := range tys[1:] {
		ty, err := genType(p)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, ", p%v %v", i+2, ty)
	}
	return b.String(), nil
}

func genType(ty ir.Type) (string, error) {
	switch t := ty.(type) {
	case *ir.BasicType:
		return t.Name, nil
	case *ir.NamedType:
		return t.Name, nil
	case *ir.ConcreteType:
		var b strings.Builder
		abTy, err := genType(t.AbstractTy)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "%v", abTy)
		argTy, err := genType(t.Args[0])
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "[%v", argTy)
		for _, arg := range t.Args[1:] {
			argTy, err := genType(arg)
			if err != nil {
				return "", err
			}
			fmt.Fprintf(&b, ", %v", argTy)
		}
		fmt.Fprint(&b, "]")
		return b.String(), nil
	case *ir.TypeVar:
		return "T" + strconv.Itoa(t.Num), nil
	}
	return "", fmt.Errorf("invalid type: %T", ty)
}

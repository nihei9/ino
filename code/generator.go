package code

import (
	_ "embed"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"strconv"
	"strings"
	"text/template"

	"github.com/nihei9/ino/ir"
)

var (
	//go:embed data_decl.tmpl
	dataDeclTmpl string

	//go:embed val_cons_decl.tmpl
	valConsDeclTmpl string

	//go:embed data_associated.tmpl
	dataAssociatedTmpl string
)

type CodeGenerator struct {
	PkgName string
	Out     io.Writer
}

func (g *CodeGenerator) Run(file *ir.File) error {
	f, err := genFile(file)
	if err != nil {
		return err
	}
	f.Name = ast.NewIdent(g.PkgName)
	fmt.Fprintln(g.Out, "// Code generated by ino. DO NOT EDIT.")
	err = format.Node(g.Out, token.NewFileSet(), f)
	if err != nil {
		return err
	}
	return nil
}

func genFile(file *ir.File) (*ast.File, error) {
	var decls []ast.Decl
	for _, decl := range file.Decls {
		d, err := genDecl(decl)
		if err != nil {
			return nil, err
		}
		decls = append(decls, d...)
	}
	return &ast.File{
		Decls: decls,
	}, nil
}

func genDecl(decl ir.Decl) ([]ast.Decl, error) {
	switch d := decl.(type) {
	case *ir.DataDecl:
		return genDataDecl(d)
	}
	return nil, fmt.Errorf("invalid declaration: %T", decl)
}

func genDataDecl(dataDecl *ir.DataDecl) ([]ast.Decl, error) {
	var decls []ast.Decl

	{
		tmpl, err := template.New("dataDeclTmpl").Parse(dataDeclTmpl)
		if err != nil {
			return nil, err
		}
		var b strings.Builder
		err = tmpl.Execute(&b, map[string]string{
			"DataName":          dataDecl.Name,
			"TyVarsWithType":    genTyVarWithType(dataDecl.TypeVarCount),
			"TyVars":            genTyVars(dataDecl.TypeVarCount),
			"MatcherStructName": "matcher_" + dataDecl.Name,
		})
		if err != nil {
			return nil, err
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, "", b.String(), 0)
		if err != nil {
			panic(err)
		}
		decls = f.Decls
	}

	{
		tmpl, err := template.New("valConsDeclTmpl").Parse(valConsDeclTmpl)
		if err != nil {
			return nil, err
		}
		for _, valCons := range dataDecl.Conss {
			fieldsStr, err := genFieldDecls(valCons.Params)
			if err != nil {
				return nil, err
			}
			paramsStr, err := genFieldsWithType(valCons.Params)
			if err != nil {
				return nil, err
			}
			var b strings.Builder
			err = tmpl.Execute(&b, map[string]any{
				"DataName":           dataDecl.Name,
				"TagName":            valCons.Name,
				"TyVarsWithType":     genTyVarWithType(dataDecl.TypeVarCount),
				"TyVars":             genTyVars(dataDecl.TypeVarCount),
				"Fields":             fieldsStr,
				"Params":             paramsStr,
				"KeyValuePairs":      genKeyValuePairs(valCons.Params),
				"MatcherStructName":  "matcher_" + dataDecl.Name,
				"TagStructName":      "tag_" + dataDecl.Name + "_" + valCons.Name,
				"MaybeTagStructName": "maybeTag_" + dataDecl.Name + "_" + valCons.Name,
				"HasFields":          len(valCons.Params) > 0,
				"FieldsMethodReturn": genFields(len(valCons.Params), "x.x."),
			})
			if err != nil {
				return nil, err
			}

			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, "", b.String(), 0)
			if err != nil {
				panic(err)
			}
			decls = append(decls, f.Decls...)
		}
	}

	{
		tmpl, err := template.New("dataAssociatedTmpl").Parse(dataAssociatedTmpl)
		if err != nil {
			return nil, err
		}
		for _, valCons := range dataDecl.Conss {
			paramStrs := make([]string, len(valCons.Params))
			for i, p := range valCons.Params {
				s, err := genType(p)
				if err != nil {
					return nil, err
				}
				paramStrs[i] = s
			}

			tyVarsStr := genSeq(dataDecl.TypeVarCount, "T", " any", "", "")

			var applyTyVars string
			if tyVarsStr != "" {
				applyTyVars = "[" + tyVarsStr + ", U any]"
			} else {
				applyTyVars = "[U any]"
			}

			var b strings.Builder
			err = tmpl.Execute(&b, map[string]any{
				"DataName":            dataDecl.Name,
				"DataTyVars":          genSeq(dataDecl.TypeVarCount, "T", "", "[", "]"),
				"ApplyTyVars":         applyTyVars,
				"TagName":             valCons.Name,
				"ApplyCallbackParams": strings.Join(paramStrs, ","),
				"HasFields":           len(valCons.Params) > 0,
				"Fields":              genFields(len(valCons.Params), ""),
			})
			if err != nil {
				return nil, err
			}

			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, "", b.String(), 0)
			if err != nil {
				panic(err)
			}
			decls = append(decls, f.Decls...)
		}
	}

	return decls, nil
}

// {prefix}1{suffix}, {prefix}2{suffix}, ..., {prefix}n{suffix}
func genSeq(n int, prefix, suffix string, l, r string) string {
	if n == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprint(&b, l)
	fmt.Fprintf(&b, "%v1%v", prefix, suffix)
	for i := 2; i <= n; i++ {
		fmt.Fprintf(&b, ", %v%v%v", prefix, i, suffix)
	}
	fmt.Fprint(&b, r)
	return b.String()
}

// [T1, T2, ...]
func genTyVars(tyVarCount int) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1")
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v", i)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// [T1 any, T2 any, ...]
func genTyVarWithType(tyVarCount int) string {
	if tyVarCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "[T1 any")
	for i := 2; i <= tyVarCount; i++ {
		fmt.Fprintf(&b, ", T%v any", i)
	}
	fmt.Fprintf(&b, "]")
	return b.String()
}

// p1 {T}
// p2 {T}
// ...
func genFieldDecls(tys []ir.Type) (string, error) {
	var b strings.Builder
	for i, p := range tys {
		ty, err := genType(p)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "p%v %v\n", i+1, ty)
	}
	return b.String(), nil
}

// {prefix}p1, {prefix}p2, ...
func genFields(fieldCount int, prefix string) string {
	if fieldCount == 0 {
		return ""
	}
	var b strings.Builder
	fmt.Fprintf(&b, "%vp1", prefix)
	for i := 2; i <= fieldCount; i++ {
		fmt.Fprintf(&b, ", %vp%v", prefix, i)
	}
	return b.String()
}

// p1 {T}, p2 {T}, ...
func genFieldsWithType(tys []ir.Type) (string, error) {
	if len(tys) == 0 {
		return "", nil
	}
	var b strings.Builder
	ty, err := genType(tys[0])
	if err != nil {
		return "", err
	}
	fmt.Fprintf(&b, "p1 %v", ty)
	for i, p := range tys[1:] {
		ty, err := genType(p)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, ", p%v %v", i+2, ty)
	}
	return b.String(), nil
}

// p1: {T},
// p2: {T},
// ...
func genKeyValuePairs(tys []ir.Type) string {
	var b strings.Builder
	for i := 1; i <= len(tys); i++ {
		fmt.Fprintf(&b, "p%v: p%v,\n", i, i)
	}
	return b.String()
}

func genType(ty ir.Type) (string, error) {
	switch t := ty.(type) {
	case *ir.BasicType:
		return t.Name, nil
	case *ir.NamedType:
		return t.Name, nil
	case *ir.ConcreteType:
		var b strings.Builder
		abTy, err := genType(t.AbstractTy)
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "%v", abTy)
		argTy, err := genType(t.Args[0])
		if err != nil {
			return "", err
		}
		fmt.Fprintf(&b, "[%v", argTy)
		for _, arg := range t.Args[1:] {
			argTy, err := genType(arg)
			if err != nil {
				return "", err
			}
			fmt.Fprintf(&b, ", %v", argTy)
		}
		fmt.Fprint(&b, "]")
		return b.String(), nil
	case *ir.TypeVar:
		return "T" + strconv.Itoa(t.Num), nil
	}
	return "", fmt.Errorf("invalid type: %T", ty)
}

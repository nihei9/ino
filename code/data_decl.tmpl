package template

var {{ .TagNumToNameMapName }} = []string {
{{ range .TagNames -}}
	"{{ . -}}",
{{ end -}}
}

type {{ .DataName }}{{ .TyVarsWithType }} interface {
	Eqer
	Maybe() *{{ .MatcherStructName }}{{ .TyVars }}
	tag() string
	tagNum() int
}

type {{ .MatcherStructName }}{{ .TyVarsWithType }} struct {
	x {{ .DataName }}{{ .TyVars }}
}

type {{ .CaseStructName }}{{ .CaseTyVars }} struct {
	match     func({{ .DataName }}{{ .TyVars }}) (U, bool)
	tagNum    int
	isDefault bool
	err       error
}

type {{ .DataName }}CaseSet{{ .CaseTyVars }} struct {
	cases []*{{ .CaseStructName }}{{ .CaseTyNames }}
}

func New{{ .DataName }}CaseSet{{ .CaseTyVars }}(cases ...*{{ .CaseStructName }}{{ .CaseTyNames }}) (*{{ .DataName }}CaseSet{{ .CaseTyNames }}, error) {
	checked := [{{ .TagCount }}+1]bool{}
	var hasDefault bool
	var firstDefaultPos int
	for i, c := range cases {
		if c.err != nil {
			return nil, c.err
		}
		checked[c.tagNum] = true
		if c.isDefault && !hasDefault {
			hasDefault = true
			firstDefaultPos = i
		}
	}
	if hasDefault && len(cases) > 1 && firstDefaultPos != len(cases) - 1 {
		return nil, fmt.Errorf("case #%v and subsequent cases are unreachable: only one default case can be placed the end", firstDefaultPos+2)
	}
	missingTags := make([]string, 0, {{ .TagCount }})
	for tagNum, ok := range checked[1:] {
		if !ok {
			missingTags = append(missingTags, {{ .TagNumToNameMapName }}[tagNum])
		}
	}
	if len(missingTags) > 0 && !hasDefault {
		var b strings.Builder
		fmt.Fprintf(&b, missingTags[0])
		for _, t := range missingTags[1:] {
			fmt.Fprintf(&b, ", %v", t)
		}
		return nil, fmt.Errorf("non-exhaustive patterns: missing tags: %v", b.String())
	}
	return &{{ .DataName }}CaseSet{{ .CaseTyNames }}{
		cases: cases,
	}, nil
}

func (s *{{ .DataName }}CaseSet{{ .CaseTyNames }}) Match(x {{ .DataName }}{{ .TyVars}}) (U, error) {
	for _, c := range s.cases {
		if result, ok := c.match(x); ok {
			return result, nil
		}
	}
	var zero U
	return zero, fmt.Errorf("non-exhaustive patterns")
}

func Case{{ .DataName}}Default{{ .CaseTyVars }}(f func({{ .DataName }}{{ .TyVars }}) U) *{{ .CaseStructName }}{{ .CaseTyNames }} {
	return &{{ .CaseStructName }}{{ .CaseTyNames }}{
		match: func(x {{ .DataName }}{{ .TyVars }}) (U, bool) {
			return f(x), true
		},
		isDefault: true,
	}
}
